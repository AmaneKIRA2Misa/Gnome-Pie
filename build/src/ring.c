/* ring.c generated by valac 0.12.0, the Vala compiler
 * generated from ring.vala, do not modify */

/* 
Copyright (c) 2011 by Simon Schneegans

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option)
any later version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>. 
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <cairo.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>


#define GNOME_PIE_TYPE_RING (gnome_pie_ring_get_type ())
#define GNOME_PIE_RING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOME_PIE_TYPE_RING, GnomePieRing))
#define GNOME_PIE_RING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOME_PIE_TYPE_RING, GnomePieRingClass))
#define GNOME_PIE_IS_RING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOME_PIE_TYPE_RING))
#define GNOME_PIE_IS_RING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOME_PIE_TYPE_RING))
#define GNOME_PIE_RING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOME_PIE_TYPE_RING, GnomePieRingClass))

typedef struct _GnomePieRing GnomePieRing;
typedef struct _GnomePieRingClass GnomePieRingClass;
typedef struct _GnomePieRingPrivate GnomePieRingPrivate;

#define GNOME_PIE_TYPE_SLICE (gnome_pie_slice_get_type ())
#define GNOME_PIE_SLICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOME_PIE_TYPE_SLICE, GnomePieSlice))
#define GNOME_PIE_SLICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOME_PIE_TYPE_SLICE, GnomePieSliceClass))
#define GNOME_PIE_IS_SLICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOME_PIE_TYPE_SLICE))
#define GNOME_PIE_IS_SLICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOME_PIE_TYPE_SLICE))
#define GNOME_PIE_SLICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOME_PIE_TYPE_SLICE, GnomePieSliceClass))

typedef struct _GnomePieSlice GnomePieSlice;
typedef struct _GnomePieSliceClass GnomePieSliceClass;
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))

#define GNOME_PIE_TYPE_COLOR (gnome_pie_color_get_type ())
#define GNOME_PIE_COLOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOME_PIE_TYPE_COLOR, GnomePieColor))
#define GNOME_PIE_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOME_PIE_TYPE_COLOR, GnomePieColorClass))
#define GNOME_PIE_IS_COLOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOME_PIE_TYPE_COLOR))
#define GNOME_PIE_IS_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOME_PIE_TYPE_COLOR))
#define GNOME_PIE_COLOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOME_PIE_TYPE_COLOR, GnomePieColorClass))

typedef struct _GnomePieColor GnomePieColor;
typedef struct _GnomePieColorClass GnomePieColorClass;
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))

struct _GnomePieRing {
	GtkWindow parent_instance;
	GnomePieRingPrivate * priv;
};

struct _GnomePieRingClass {
	GtkWindowClass parent_class;
};

struct _GnomePieRingPrivate {
	cairo_surface_t* imgRing_;
	cairo_surface_t* imgGlow_;
	cairo_surface_t* imgArrow_;
	gdouble rot_;
	gdouble baseRot_;
	GnomePieSlice** slices_;
	gint slices__length1;
	gint _slices__size_;
	gint _activeSlice;
	gint size_;
};


static gpointer gnome_pie_ring_parent_class = NULL;
extern gdouble gnome_pie_utils_refresh_rate;

GType gnome_pie_ring_get_type (void) G_GNUC_CONST;
GType gnome_pie_slice_get_type (void) G_GNUC_CONST;
#define GNOME_PIE_RING_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GNOME_PIE_TYPE_RING, GnomePieRingPrivate))
enum  {
	GNOME_PIE_RING_DUMMY_PROPERTY
};
static void gnome_pie_ring_mousePressed (GnomePieRing* self, gint button, gint x, gint y);
void gnome_pie_slice_mousePressed (GnomePieSlice* self);
static void gnome_pie_ring_addSlice (GnomePieRing* self, const gchar* command, const gchar* icon);
GnomePieSlice* gnome_pie_slice_new (const gchar* command, const gchar* icon);
GnomePieSlice* gnome_pie_slice_construct (GType object_type, const gchar* command, const gchar* icon);
static void _vala_array_add1 (GnomePieSlice*** array, int* length, int* size, GnomePieSlice* value);
static gboolean gnome_pie_ring_draw (GnomePieRing* self, GtkWidget* da, GdkEventExpose* event);
GType gnome_pie_color_get_type (void) G_GNUC_CONST;
GnomePieColor* gnome_pie_slice_get_color (GnomePieSlice* self);
gfloat gnome_pie_color_get_r (GnomePieColor* self);
gfloat gnome_pie_color_get_g (GnomePieColor* self);
gfloat gnome_pie_color_get_b (GnomePieColor* self);
void gnome_pie_slice_draw (GnomePieSlice* self, cairo_t* ctx, gdouble mouse_dir, gint position, gint total);
gboolean gnome_pie_slice_get_active (GnomePieSlice* self);
GnomePieRing* gnome_pie_ring_new (void);
GnomePieRing* gnome_pie_ring_construct (GType object_type);
static gboolean _lambda0_ (GdkEventButton* e, GnomePieRing* self);
static gboolean __lambda0__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static gboolean _gnome_pie_ring_draw_gtk_widget_expose_event (GtkWidget* _sender, GdkEventExpose* event, gpointer self);
static void _gtk_main_quit_gtk_object_destroy (GtkObject* _sender, gpointer self);
static void gnome_pie_ring_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static void gnome_pie_ring_mousePressed (GnomePieRing* self, gint button, gint x, gint y) {
	g_return_if_fail (self != NULL);
	if (button == 1) {
		{
			gint s;
			s = 0;
			{
				gboolean _tmp0_;
				_tmp0_ = TRUE;
				while (TRUE) {
					if (!_tmp0_) {
						s = s + 1;
					}
					_tmp0_ = FALSE;
					if (!(s < self->priv->slices__length1)) {
						break;
					}
					gnome_pie_slice_mousePressed (self->priv->slices_[s]);
				}
			}
		}
		gtk_widget_hide ((GtkWidget*) self);
	}
}


static void _vala_array_add1 (GnomePieSlice*** array, int* length, int* size, GnomePieSlice* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GnomePieSlice*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void gnome_pie_ring_addSlice (GnomePieRing* self, const gchar* command, const gchar* icon) {
	GnomePieSlice* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (command != NULL);
	g_return_if_fail (icon != NULL);
	_tmp0_ = gnome_pie_slice_new (command, icon);
	_vala_array_add1 (&self->priv->slices_, &self->priv->slices__length1, &self->priv->_slices__size_, _tmp0_);
}


static gboolean gnome_pie_ring_draw (GnomePieRing* self, GtkWidget* da, GdkEventExpose* event) {
	gboolean result = FALSE;
	gdouble mouse_x;
	gdouble mouse_y;
	gint _tmp0_;
	gint _tmp1_;
	cairo_t* _tmp2_ = NULL;
	cairo_t* ctx;
	gdouble _tmp3_;
	gdouble distance;
	gdouble angle;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (da != NULL, FALSE);
	mouse_x = (gdouble) 0;
	mouse_y = (gdouble) 0;
	gtk_widget_get_pointer ((GtkWidget*) self, &_tmp0_, &_tmp1_);
	mouse_x = (gdouble) _tmp0_;
	mouse_y = (gdouble) _tmp1_;
	_tmp2_ = gdk_cairo_create ((GdkDrawable*) da->window);
	ctx = _tmp2_;
	cairo_set_operator (ctx, CAIRO_OPERATOR_CLEAR);
	cairo_paint (ctx);
	mouse_x = mouse_x - (self->priv->size_ * 0.5);
	mouse_y = mouse_y - (self->priv->size_ * 0.5);
	_tmp3_ = sqrt ((mouse_x * mouse_x) + (mouse_y * mouse_y));
	distance = _tmp3_;
	self->priv->baseRot_ = self->priv->baseRot_ + (0.5 / gnome_pie_utils_refresh_rate);
	cairo_set_operator (ctx, CAIRO_OPERATOR_DEST_OVER);
	cairo_set_source_rgb (ctx, (gdouble) 1, (gdouble) 1, (gdouble) 1);
	angle = (gdouble) (-1);
	if (distance > 45) {
		gdouble _tmp4_;
		gdouble _tmp5_;
		gdouble _tmp6_;
		gdouble test;
		gdouble _tmp7_;
		gdouble _tmp8_;
		gdouble _tmp9_ = 0.0;
		gdouble alpha;
		_tmp4_ = acos (mouse_x / distance);
		angle = _tmp4_;
		_tmp5_ = sin (self->priv->rot_);
		_tmp6_ = cos (self->priv->rot_);
		test = (mouse_x * _tmp5_) - (mouse_y * _tmp6_);
		if (mouse_y < 0) {
			angle = (2 * G_PI) - angle;
		}
		_tmp7_ = fabs (angle - self->priv->rot_);
		if (_tmp7_ > 0.15) {
			if (test < 0) {
				self->priv->rot_ = self->priv->rot_ + (8.0 / gnome_pie_utils_refresh_rate);
			} else {
				self->priv->rot_ = self->priv->rot_ - (8.0 / gnome_pie_utils_refresh_rate);
			}
		} else {
			self->priv->rot_ = angle;
		}
		_tmp8_ = fmod (self->priv->rot_ + (2 * G_PI), 2 * G_PI);
		self->priv->rot_ = _tmp8_;
		cairo_translate (ctx, self->priv->size_ * 0.5, self->priv->size_ * 0.5);
		cairo_rotate (ctx, self->priv->rot_);
		if (distance > 65) {
			_tmp9_ = 1.0;
		} else {
			_tmp9_ = 1.0 - (0.05 * (65 - distance));
		}
		alpha = _tmp9_;
		cairo_set_source_surface (ctx, self->priv->imgArrow_, (gdouble) (-75), (gdouble) (-75));
		cairo_paint_with_alpha (ctx, alpha);
		cairo_identity_matrix (ctx);
	}
	cairo_translate (ctx, self->priv->size_ * 0.5, self->priv->size_ * 0.5);
	cairo_rotate (ctx, self->priv->baseRot_);
	cairo_set_source_surface (ctx, self->priv->imgRing_, (gdouble) (-75), (gdouble) (-75));
	cairo_paint (ctx);
	cairo_set_source_surface (ctx, self->priv->imgGlow_, (gdouble) (-75), (gdouble) (-75));
	cairo_paint_with_alpha (ctx, 0.7);
	cairo_set_operator (ctx, CAIRO_OPERATOR_ATOP);
	if (self->priv->_activeSlice >= 0) {
		GnomePieColor* _tmp10_ = NULL;
		gfloat _tmp11_;
		GnomePieColor* _tmp12_ = NULL;
		gfloat _tmp13_;
		GnomePieColor* _tmp14_ = NULL;
		gfloat _tmp15_;
		_tmp10_ = gnome_pie_slice_get_color (self->priv->slices_[self->priv->_activeSlice]);
		_tmp11_ = gnome_pie_color_get_r (_tmp10_);
		_tmp12_ = gnome_pie_slice_get_color (self->priv->slices_[self->priv->_activeSlice]);
		_tmp13_ = gnome_pie_color_get_g (_tmp12_);
		_tmp14_ = gnome_pie_slice_get_color (self->priv->slices_[self->priv->_activeSlice]);
		_tmp15_ = gnome_pie_color_get_b (_tmp14_);
		cairo_set_source_rgb (ctx, (gdouble) _tmp11_, (gdouble) _tmp13_, (gdouble) _tmp15_);
	} else {
		cairo_set_source_rgb (ctx, 0.5, 0.5, 0.5);
	}
	cairo_rectangle (ctx, (-self->priv->size_) * 0.5, (-self->priv->size_) * 0.5, (gdouble) self->priv->size_, (gdouble) self->priv->size_);
	cairo_fill (ctx);
	cairo_stroke (ctx);
	cairo_set_operator (ctx, CAIRO_OPERATOR_OVER);
	self->priv->_activeSlice = -1;
	{
		gint s;
		s = 0;
		{
			gboolean _tmp16_;
			_tmp16_ = TRUE;
			while (TRUE) {
				gboolean _tmp17_;
				if (!_tmp16_) {
					s = s + 1;
				}
				_tmp16_ = FALSE;
				if (!(s < self->priv->slices__length1)) {
					break;
				}
				cairo_identity_matrix (ctx);
				cairo_translate (ctx, self->priv->size_ * 0.5, self->priv->size_ * 0.5);
				gnome_pie_slice_draw (self->priv->slices_[s], ctx, angle, s, self->priv->slices__length1);
				_tmp17_ = gnome_pie_slice_get_active (self->priv->slices_[s]);
				if (_tmp17_) {
					self->priv->_activeSlice = s;
				}
			}
		}
	}
	result = TRUE;
	_cairo_destroy0 (ctx);
	return result;
}


static gboolean _lambda0_ (GdkEventButton* e, GnomePieRing* self) {
	gboolean result = FALSE;
	gnome_pie_ring_mousePressed (self, (gint) (*e).button, (gint) (*e).x, (gint) (*e).y);
	result = TRUE;
	return result;
}


static gboolean __lambda0__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = _lambda0_ (event, self);
	return result;
}


static gboolean _gnome_pie_ring_draw_gtk_widget_expose_event (GtkWidget* _sender, GdkEventExpose* event, gpointer self) {
	gboolean result;
	result = gnome_pie_ring_draw (self, _sender, event);
	return result;
}


static void _gtk_main_quit_gtk_object_destroy (GtkObject* _sender, gpointer self) {
	gtk_main_quit ();
}


GnomePieRing* gnome_pie_ring_construct (GType object_type) {
	GnomePieRing * self = NULL;
	GdkScreen* _tmp0_ = NULL;
	GdkColormap* _tmp1_ = NULL;
	cairo_surface_t* _tmp2_ = NULL;
	cairo_surface_t* _tmp3_ = NULL;
	cairo_surface_t* _tmp4_ = NULL;
	GnomePieSlice** _tmp5_ = NULL;
	self = (GnomePieRing*) g_object_new (object_type, NULL);
	gtk_window_set_title ((GtkWindow*) self, "Gnome-Pie");
	gtk_window_set_default_size ((GtkWindow*) self, self->priv->size_, self->priv->size_);
	gtk_window_set_skip_taskbar_hint ((GtkWindow*) self, TRUE);
	gtk_window_set_skip_pager_hint ((GtkWindow*) self, TRUE);
	gtk_window_set_keep_above ((GtkWindow*) self, TRUE);
	gtk_window_set_type_hint ((GtkWindow*) self, GDK_WINDOW_TYPE_HINT_NORMAL);
	_tmp0_ = gtk_window_get_screen ((GtkWindow*) self);
	_tmp1_ = gdk_screen_get_rgba_colormap (_tmp0_);
	gtk_widget_set_colormap ((GtkWidget*) self, _tmp1_);
	((GtkWindow*) self)->position = (guint) GTK_WIN_POS_MOUSE;
	gtk_window_set_decorated ((GtkWindow*) self, FALSE);
	gtk_widget_set_app_paintable ((GtkWidget*) self, TRUE);
	gtk_widget_add_events ((GtkWidget*) self, (gint) GDK_BUTTON_PRESS_MASK);
	g_signal_connect_object ((GtkWidget*) self, "button-press-event", (GCallback) __lambda0__gtk_widget_button_press_event, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "expose-event", (GCallback) _gnome_pie_ring_draw_gtk_widget_expose_event, self, 0);
	g_signal_connect ((GtkObject*) self, "destroy", (GCallback) _gtk_main_quit_gtk_object_destroy, NULL);
	_tmp2_ = cairo_image_surface_create_from_png ("data/ring.png");
	_cairo_surface_destroy0 (self->priv->imgRing_);
	self->priv->imgRing_ = _tmp2_;
	_tmp3_ = cairo_image_surface_create_from_png ("data/glow.png");
	_cairo_surface_destroy0 (self->priv->imgGlow_);
	self->priv->imgGlow_ = _tmp3_;
	_tmp4_ = cairo_image_surface_create_from_png ("data/arrow.png");
	_cairo_surface_destroy0 (self->priv->imgArrow_);
	self->priv->imgArrow_ = _tmp4_;
	_tmp5_ = g_new0 (GnomePieSlice*, 0 + 1);
	self->priv->slices_ = (_vala_array_free (self->priv->slices_, self->priv->slices__length1, (GDestroyNotify) g_object_unref), NULL);
	self->priv->slices_ = _tmp5_;
	self->priv->slices__length1 = 0;
	self->priv->_slices__size_ = 0;
	gnome_pie_ring_addSlice (self, "firefox.desktop", "firefox");
	gnome_pie_ring_addSlice (self, "eog.desktop", "eog");
	gnome_pie_ring_addSlice (self, "gnome-terminal.desktop", "terminal");
	gnome_pie_ring_addSlice (self, "thunderbird.desktop", "thunderbird");
	gnome_pie_ring_addSlice (self, "blender.desktop", "blender");
	return self;
}


GnomePieRing* gnome_pie_ring_new (void) {
	return gnome_pie_ring_construct (GNOME_PIE_TYPE_RING);
}


static void gnome_pie_ring_class_init (GnomePieRingClass * klass) {
	gnome_pie_ring_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GnomePieRingPrivate));
	G_OBJECT_CLASS (klass)->finalize = gnome_pie_ring_finalize;
}


static void gnome_pie_ring_instance_init (GnomePieRing * self) {
	self->priv = GNOME_PIE_RING_GET_PRIVATE (self);
	self->priv->rot_ = 0.0;
	self->priv->baseRot_ = 0.0;
	self->priv->_activeSlice = -1;
	self->priv->size_ = 400;
}


static void gnome_pie_ring_finalize (GObject* obj) {
	GnomePieRing * self;
	self = GNOME_PIE_RING (obj);
	_cairo_surface_destroy0 (self->priv->imgRing_);
	_cairo_surface_destroy0 (self->priv->imgGlow_);
	_cairo_surface_destroy0 (self->priv->imgArrow_);
	self->priv->slices_ = (_vala_array_free (self->priv->slices_, self->priv->slices__length1, (GDestroyNotify) g_object_unref), NULL);
	G_OBJECT_CLASS (gnome_pie_ring_parent_class)->finalize (obj);
}


GType gnome_pie_ring_get_type (void) {
	static volatile gsize gnome_pie_ring_type_id__volatile = 0;
	if (g_once_init_enter (&gnome_pie_ring_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GnomePieRingClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gnome_pie_ring_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GnomePieRing), 0, (GInstanceInitFunc) gnome_pie_ring_instance_init, NULL };
		GType gnome_pie_ring_type_id;
		gnome_pie_ring_type_id = g_type_register_static (GTK_TYPE_WINDOW, "GnomePieRing", &g_define_type_info, 0);
		g_once_init_leave (&gnome_pie_ring_type_id__volatile, gnome_pie_ring_type_id);
	}
	return gnome_pie_ring_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



