/* utils.c generated by valac 0.12.0, the Vala compiler
 * generated from utils.vala, do not modify */

/* 
Copyright (c) 2011 by Simon Schneegans

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option)
any later version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>. 
*/

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <cairo.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>


#define GNOME_PIE_TYPE_COLOR (gnome_pie_color_get_type ())
#define GNOME_PIE_COLOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNOME_PIE_TYPE_COLOR, GnomePieColor))
#define GNOME_PIE_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNOME_PIE_TYPE_COLOR, GnomePieColorClass))
#define GNOME_PIE_IS_COLOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNOME_PIE_TYPE_COLOR))
#define GNOME_PIE_IS_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNOME_PIE_TYPE_COLOR))
#define GNOME_PIE_COLOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNOME_PIE_TYPE_COLOR, GnomePieColorClass))

typedef struct _GnomePieColor GnomePieColor;
typedef struct _GnomePieColorClass GnomePieColorClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block1Data Block1Data;

struct _Block1Data {
	int _ref_count_;
	gint i;
	GtkWindow* window;
};


extern gdouble gnome_pie_utils_refresh_rate;
gdouble gnome_pie_utils_refresh_rate = 60.0;

GType gnome_pie_color_get_type (void) G_GNUC_CONST;
void gnome_pie_utils_get_icon_color (cairo_surface_t* icon, GnomePieColor** color);
GnomePieColor* gnome_pie_color_new_from_rgb (gfloat red, gfloat green, gfloat blue);
GnomePieColor* gnome_pie_color_construct_from_rgb (GType object_type, gfloat red, gfloat green, gfloat blue);
gfloat gnome_pie_color_get_s (GnomePieColor* self);
void gnome_pie_color_set_s (GnomePieColor* self, gfloat value);
void gnome_pie_color_set_v (GnomePieColor* self, gfloat value);
void gnome_pie_utils_present_window (GtkWindow* window);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (Block1Data* _data1_);
static gboolean _lambda1_ (Block1Data* _data1_);
gboolean gnome_pie_utils_try_grab_window (GtkWindow* window);
static gboolean __lambda1__gsource_func (gpointer self);
void gnome_pie_utils_unpresent_window (GtkWindow* window);


void gnome_pie_utils_get_icon_color (cairo_surface_t* icon, GnomePieColor** color) {
	GnomePieColor* _color = NULL;
	guchar* _tmp0_ = NULL;
	guchar* data;
	gint data_length1;
	gint _data_size_;
	gint _tmp1_;
	guint width;
	gint _tmp2_;
	guint height;
	gint _tmp3_;
	guint row_bytes;
	gdouble total;
	gdouble rtotal;
	gdouble gtotal;
	gdouble btotal;
	GnomePieColor* _tmp10_ = NULL;
	gfloat _tmp11_;
	g_return_if_fail (icon != NULL);
	_tmp0_ = cairo_image_surface_get_data (icon);
	data = _tmp0_;
	data_length1 = -1;
	_data_size_ = -1;
	_tmp1_ = cairo_image_surface_get_width (icon);
	width = (guint) _tmp1_;
	_tmp2_ = cairo_image_surface_get_height (icon);
	height = (guint) _tmp2_;
	_tmp3_ = cairo_image_surface_get_stride (icon);
	row_bytes = (guint) _tmp3_;
	total = 0.0;
	rtotal = 0.0;
	gtotal = 0.0;
	btotal = 0.0;
	{
		guint i;
		i = (guint) 0;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				if (!_tmp4_) {
					i = i + 1;
				}
				_tmp4_ = FALSE;
				if (!(i < width)) {
					break;
				}
				{
					guint j;
					j = (guint) 0;
					{
						gboolean _tmp5_;
						_tmp5_ = TRUE;
						while (TRUE) {
							guint pixel;
							gdouble b;
							gdouble g;
							gdouble r;
							gdouble a;
							gdouble _tmp6_;
							gdouble _tmp7_;
							gdouble _tmp8_;
							gdouble _tmp9_;
							gdouble saturation;
							gdouble relevance;
							if (!_tmp5_) {
								j = j + 1;
							}
							_tmp5_ = FALSE;
							if (!(j < height)) {
								break;
							}
							pixel = (j * row_bytes) + (i * 4);
							b = data[pixel + 0] / 255.0;
							g = data[pixel + 1] / 255.0;
							r = data[pixel + 2] / 255.0;
							a = data[pixel + 3] / 255.0;
							_tmp6_ = fmax (g, b);
							_tmp7_ = fmax (r, _tmp6_);
							_tmp8_ = fmin (g, b);
							_tmp9_ = fmin (r, _tmp8_);
							saturation = _tmp7_ - _tmp9_;
							relevance = 0.1 + ((0.9 * a) * saturation);
							rtotal = rtotal + (r * relevance);
							gtotal = gtotal + (g * relevance);
							btotal = btotal + (b * relevance);
							total = total + relevance;
						}
					}
				}
			}
		}
	}
	_tmp10_ = gnome_pie_color_new_from_rgb ((gfloat) (rtotal / total), (gfloat) (gtotal / total), (gfloat) (btotal / total));
	_g_object_unref0 (_color);
	_color = _tmp10_;
	_tmp11_ = gnome_pie_color_get_s (_color);
	if (_tmp11_ > 0.15f) {
		gnome_pie_color_set_s (_color, 0.65f);
	}
	gnome_pie_color_set_v (_color, 1.0f);
	if (color) {
		*color = _color;
	} else {
		_g_object_unref0 (_color);
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (Block1Data* _data1_) {
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		_g_object_unref0 (_data1_->window);
		g_slice_free (Block1Data, _data1_);
	}
}


static gboolean _lambda1_ (Block1Data* _data1_) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	if (_data1_->i >= 100) {
		result = FALSE;
		return result;
	}
	_data1_->i = _data1_->i + 1;
	_tmp0_ = gnome_pie_utils_try_grab_window (_data1_->window);
	result = !_tmp0_;
	return result;
}


static gboolean __lambda1__gsource_func (gpointer self) {
	gboolean result;
	result = _lambda1_ (self);
	return result;
}


void gnome_pie_utils_present_window (GtkWindow* window) {
	Block1Data* _data1_;
	guint32 _tmp0_;
	guint32 timestamp;
	GdkWindow* _tmp1_ = NULL;
	GdkWindow* _tmp2_ = NULL;
	g_return_if_fail (window != NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->window = _g_object_ref0 (window);
	_tmp0_ = gtk_get_current_event_time ();
	timestamp = _tmp0_;
	gtk_window_present_with_time (_data1_->window, timestamp);
	_tmp1_ = gtk_widget_get_window ((GtkWidget*) _data1_->window);
	gdk_window_raise (_tmp1_);
	_tmp2_ = gtk_widget_get_window ((GtkWidget*) _data1_->window);
	gdk_window_focus (_tmp2_, timestamp);
	_data1_->i = 0;
	g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 100, __lambda1__gsource_func, block1_data_ref (_data1_), block1_data_unref);
	block1_data_unref (_data1_);
	_data1_ = NULL;
}


void gnome_pie_utils_unpresent_window (GtkWindow* window) {
	guint32 _tmp0_;
	guint32 time;
	g_return_if_fail (window != NULL);
	_tmp0_ = gtk_get_current_event_time ();
	time = _tmp0_;
	gdk_pointer_ungrab (time);
	gdk_keyboard_ungrab (time);
	gtk_grab_remove ((GtkWidget*) window);
}


gboolean gnome_pie_utils_try_grab_window (GtkWindow* window) {
	gboolean result = FALSE;
	guint32 _tmp0_;
	guint time;
	GdkWindow* _tmp1_ = NULL;
	GdkGrabStatus _tmp2_;
	g_return_val_if_fail (window != NULL, FALSE);
	_tmp0_ = gtk_get_current_event_time ();
	time = (guint) _tmp0_;
	_tmp1_ = gtk_widget_get_window ((GtkWidget*) window);
	_tmp2_ = gdk_pointer_grab (_tmp1_, TRUE, (GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK) | GDK_POINTER_MOTION_MASK, NULL, NULL, (guint32) time);
	if (_tmp2_ == GDK_GRAB_SUCCESS) {
		GdkWindow* _tmp3_ = NULL;
		GdkGrabStatus _tmp4_;
		_tmp3_ = gtk_widget_get_window ((GtkWidget*) window);
		_tmp4_ = gdk_keyboard_grab (_tmp3_, TRUE, (guint32) time);
		if (_tmp4_ == GDK_GRAB_SUCCESS) {
			gtk_grab_add ((GtkWidget*) window);
			result = TRUE;
			return result;
		} else {
			gdk_pointer_ungrab ((guint32) time);
			result = FALSE;
			return result;
		}
	}
	result = FALSE;
	return result;
}



